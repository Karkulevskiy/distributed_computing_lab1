#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// --- ПОЯСНЕНИЕ: M_PI — это просто число "пи" (3.14159...).
// Оно нужно, чтобы задать источник тепла, который красиво выглядит.
// Не все компиляторы знают M_PI, поэтому определим сами, если вдруг не знают.
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// --- ПОЯСНЕНИЕ:
// EPS — насколько маленьким должно стать изменение температуры,
// чтобы мы решили: "всё, равновесие достигнуто".
// Чем меньше EPS — тем точнее, но дольше считает.
// Мы взяли 0.0001 — достаточно для демонстрации.
#define EPS 1e-4

// --- Максимальное число итераций, чтобы не зациклиться навсегда.
#define MAX_ITER 5000

// --- ПОЯСНЕНИЕ: Это функция, которая говорит —
// "насколько сильно греет в точке (x, y)".
// Мы выбрали такую, чтобы решение было красивым:
// температура будет похожа на холм в центре и 0 на краях.
// (Это просто пример — можно поставить любую функцию!)
double f_func(double x, double y)
{
    return -2.0 * M_PI * M_PI * sin(M_PI * x) * sin(M_PI * y);
}

int main(int argc, char **argv)
{
    // --- Запускаем MPI (систему для параллельных вычислений)
    MPI_Init(&argc, &argv);

    int rank, size;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank); // номер текущего процесса (0, 1, 2...)
    MPI_Comm_size(MPI_COMM_WORLD, &size); // сколько всего процессов запущено

    // --- Проверка: передали ли размер сетки?
    if (argc != 2 && rank == 0)
    {
        fprintf(stderr, "Usage: %s N\n", argv[0]); // N — размер сетки
        MPI_Abort(MPI_COMM_WORLD, 1);              // если нет — аварийно завершаем все процессы
    }

    // --- Читаем N: сколько точек по одному направлению (включая края)
    int N = 100;
    if (argc == 2)
        N = atoi(argv[1]);
    if (N < 3)
        N = 100; // минимум 3×3: край-внутри-край

    // --- inner = сколько ВНУТРЕННИХ точек (без краёв)
    int inner = N - 2;

    // --- h = шаг сетки (расстояние между соседними точками)
    // Например, если N=101, то h = 1/100 = 0.01
    double h = 1.0 / (N - 1);

    // --- c = температура на краях (мы берём 0 для простоты)
    double c = 0.0;

    // --- РАЗБИВКА ПО ПРОЦЕССАМ (1D — по строкам, проще и надёжнее)
    // Сколько строк внутренних узлов достанется каждому процессу?
    int rows_per_proc = inner / size; // базовое количество
    int remainder = inner % size;     // остаток, который распределим первым процессам

    // Сколько строк будет у ТЕКУЩЕГО процесса?
    int local_rows = rows_per_proc + (rank < remainder ? 1 : 0);

    // С какой ГЛОБАЛЬНОЙ строки начинается блок этого процесса?
    // (напоминаю: глобальные строки = от 1 до N-2, потому что 0 и N-1 — границы)
    int start_row = rank * rows_per_proc + (rank < remainder ? rank : remainder);

    // --- ЛОКАЛЬНАЯ СЕТКА:
    // Каждый процесс хранит:
    //   - свои строки (local_rows)
    //   + 1 строку сверху (гостевая ячейка от соседа сверху)
    //   + 1 строку снизу (гостевая ячейка от соседа снизу)
    // Итого: (local_rows + 2) строк по N столбцов.
    double *u = calloc((local_rows + 2) * N, sizeof(double));     // текущие температуры
    double *u_new = calloc((local_rows + 2) * N, sizeof(double)); // временный буфер

    // --- Инициализация: по бокам (j=0 и j=N-1) — всегда температура = c (границы!)
    for (int i = 0; i < local_rows + 2; i++)
    {
        u[i * N + 0] = c;     // левый край
        u[i * N + N - 1] = c; // правый край
        u_new[i * N + 0] = c;
        u_new[i * N + N - 1] = c;
    }

    // --- Начинаем замер времени (только параллельных вычислений)
    double start_time = MPI_Wtime();

    // --- ГЛАВНЫЙ ЦИКЛ: итерации до сходимости
    for (int iter = 0; iter < MAX_ITER; iter++)
    {

        // --- ОПРЕДЕЛЯЕМ СОСЕДЕЙ ПО ВЕРТИКАЛИ (сверху и снизу)
        int north = rank - 1; // процесс сверху
        int south = rank + 1; // процесс снизу
        if (north < 0)
            north = MPI_PROC_NULL; // если мы самый верхний — нет соседа сверху
        if (south >= size)
            south = MPI_PROC_NULL; // если мы самый нижний — нет соседа снизу

        // --- АСИНХРОННЫЙ ОБМЕН ГРАНИЦАМИ:
        // Каждый процесс отправляет свою ВЕРХНЮЮ рабочую строку вверх
        // и НИЖНЮЮ — вниз. И принимает чужие границы.
        MPI_Request req[4];
        int nreq = 0;

        if (north != MPI_PROC_NULL)
        {
            // Принимаем строку СВЕРХУ в самую верхнюю гостевую строку (индекс 0)
            MPI_Irecv(u, N, MPI_DOUBLE, north, 0, MPI_COMM_WORLD, &req[nreq++]);
            // Отправляем свою первую рабочую строку (индекс 1) наверх
            MPI_Isend(&u[(1) * N], N, MPI_DOUBLE, north, 1, MPI_COMM_WORLD, &req[nreq++]);
        }
        if (south != MPI_PROC_NULL)
        {
            // Принимаем строку СНИЗУ в самую нижнюю гостевую строку (индекс local_rows+1)
            MPI_Irecv(&u[(local_rows + 1) * N], N, MPI_DOUBLE, south, 1, MPI_COMM_WORLD, &req[nreq++]);
            // Отправляем свою последнюю рабочую строку (индекс local_rows) вниз
            MPI_Isend(&u[(local_rows)*N], N, MPI_DOUBLE, south, 0, MPI_COMM_WORLD, &req[nreq++]);
        }
        if (nreq > 0)
            MPI_Waitall(nreq, req, MPI_STATUSES_IGNORE); // ждём завершения обмена

        // --- УСТАНАВЛИВАЕМ ГЛОБАЛЬНЫЕ ГРАНИЦЫ ПО ВЕРТИКАЛИ:
        // Если мы верхний процесс — наша верхняя гостевая строка = граница (c)
        if (rank == 0)
        {
            for (int j = 0; j < N; j++)
                u[0 * N + j] = c;
        }
        // Если мы нижний процесс — наша нижняя гостевая строка = граница (c)
        if (rank == size - 1)
        {
            for (int j = 0; j < N; j++)
                u[(local_rows + 1) * N + j] = c;
        }

        // --- ВОЛНОВАЯ СХЕМА: RED-BLACK (две "волны")
        double local_max = 0.0; // максимальное изменение в этом процессе

        // Сначала обновляем одну "волну" (цвет), потом другую
        for (int color = 0; color < 2; color++)
        {
            // Проходим по всем СВОИМ строкам (локальным)
            for (int i = 0; i < local_rows; i++)
            {
                // Глобальный номер строки (в общей сетке)
                int global_i = start_row + i + 1; // +1, потому что граница — строка 0
                // Проходим по столбцам (кроме границ j=0 и j=N-1)
                for (int j = 1; j < N - 1; j++)
                {
                    // Проверяем: подходит ли клетка под текущий "цвет"?
                    // (i + j) % 2 == color — это и есть шахматная раскраска
                    if ((i + j) % 2 != color)
                        continue;

                    // Координаты в физическом пространстве [0,1]x[0,1]
                    double x = global_i * h;
                    double y = j * h;

                    // Формула Гаусса-Зейделя:
                    // новая температура = среднее от 4 соседей - поправка на источник
                    double val = 0.25 * (u[i * N + j] +           // сверху (гостевая или локальная)
                                         u[(i + 2) * N + j] +     // снизу
                                         u[(i + 1) * N + j - 1] + // слева
                                         u[(i + 1) * N + j + 1] - // справа
                                         h * h * f_func(x, y)     // поправка на источник
                                        );

                    // Насколько изменилась температура?
                    double diff = fabs(val - u[(i + 1) * N + j]);
                    if (diff > local_max)
                        local_max = diff;

                    // Сохраняем новое значение во временный буфер
                    u_new[(i + 1) * N + j] = val;
                }
            }

            // --- КОПИРУЕМ ОБНОВЛЁННЫЕ ЗНАЧЕНИЯ ОБРАТНО В u
            // (чтобы следующие клетки в этой же волне могли использовать актуальные данные)
            for (int i = 0; i < local_rows; i++)
            {
                for (int j = 1; j < N - 1; j++)
                {
                    u[(i + 1) * N + j] = u_new[(i + 1) * N + j];
                }
            }
        }

        // --- СОБИРАЕМ МАКСИМАЛЬНОЕ ИЗМЕНЕНИЕ СО ВСЕХ ПРОЦЕССОВ
        double global_max;
        MPI_Allreduce(&local_max, &global_max, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);

        // --- ПРОВЕРЯЕМ УСЛОВИЕ ОСТАНОВКИ
        if (global_max < EPS)
        {
            if (rank == 0)
            {
                double end_time = MPI_Wtime();
                printf("Время выполнения: %.6f секунд\n", end_time - start_time);
                printf("Число итераций: %d\n", iter + 1);
            }
            break; // выходим из цикла — решение найдено!
        }
    }

    // --- ОЧИСТКА ПАМЯТИ
    free(u);
    free(u_new);

    // --- Завершаем MPI
    MPI_Finalize();
    return 0;
}
